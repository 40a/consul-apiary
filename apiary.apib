FORMAT: 1A

# Consul HTTP API

The main interface to Consul is a RESTful HTTP API. The API can be used for CRUD
for nodes, services, checks, and configuration. The endpoints are versioned to
enable changes without breaking backwards compatibility.

# Group KV

## Key/Value store [/v1/kv/{+key}{?dc,wait,index,token,keys,recurse,separator,stale,consistent,pretty,raw,flags,cas,acquire,release}]

The KV endpoint is used to expose a simple **key/value store**.  This can be
used to store service configurations or other meta data in a simple way.  It has
only a single endpoint: `/v1/kv/<key>`.

By default the datacenter of the agent is queried, however the dc can be
provided using the `dc` query parameter. If a client wants to write to all
Datacenters, one request per datacenter must be made.

The KV endpoint supports the use of ACL tokens.

+ Parameters
    + dc (optional, string) ... datacenter
    + key (optional, path) ... the key
    + token (optional, string) ... per-request ACL token

### Retrieve key [GET]

Retrieve the specified key, or if `recurse` is provided, return all keys with
the given prefix.  If `keys` is provided, return a list of the keys under the
given prefix; used with `separator`, list only up to a given separator.

A blocking query can be used to wait for a value to change.

If `recurse` is used, the `X-Consul-Index` corresponds to the latest
`ModifyIndex` and so a blocking query waits until any of the listed keys are
updated.

This endpoint supports blocking queries and all consistency modes.

#### Response Payload

- `CreateIndex` - internal index value that represents when the entry was created
- `ModifyIndex` - last index that modified this key; corresponds to the `X-Consul-Index` header value
- `LockIndex`   - last index of a successful lock acquisition
- `Key`         - full path of the entry
- `Flags`       - opaque unsigned integer that can be attached to each entry; use of this is left totally to the user
- `Session`     - key provides the session that owns the lock
- `Value`       - a base64 key value

+ Parameters
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + recurse (optional)                ... return all keys with the given prefix
    + keys (optional)                   ... return a list of the keys under the given prefix
    + separator (optional, string)      ... with `keys`, list only up to a given separator
    + raw (optional)                    ... with non-recursive get, response is raw value of key, without encoding
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode
    + pretty (optional) ... if provided, formatted JSON is returned

+ Request single-key

+ Response 200 (application/json)
    + Headers
        
            X-Consul-Index: <handle>
            X-Consul-LastContact: last time a server was contacted (ms)
            X-Consul-KnownLeader: boolean if there is a known leader

    + Body

            [
                {
                    "CreateIndex": 100,
                    "ModifyIndex": 200,
                    "LockIndex": 200,
                    "Key": "zip",
                    "Flags": 0,
                    "Value": "dGVzdA==",
                    "Session": "adf4238a-882b-9ddc-4a9d-5b6758e4159e"
                }
            ]

+ Response 404

+ Request list-keys

+ Response 200 (application/json)

    + Body
    
            @todo

### Create or Update Key [PUT]

The return value is simply either `true` or `false`.
If `false` is returned, then the update has not taken place.

Complex locking and synchronization operations are possbile.

#### Check-And-Set

Clients may build more complex synchronization primives using the Check-And-Set
operation with the `cas` parameter.

If the `cas` value is `0`, Consul will only create the key if it does not already exist.
If the `cas` value is non-zero, then the key is only updated if the index
matches the `ModifyIndex` for the key.

#### Locking

Locking is a useful feature that allows leader election to be built on top of
Consul.

Acquire a lock by providing the `acquire` parameter with a valid session ID. If
the lock is not held, this increments the `LockIndex` and sets the `Session`
value of the key in addition to updating the key contents. A key does not need
to exist to be acquired.

Yield a lock by providing the `release` parameter with the ID of the session
holding the lock.Â  This will leave the `LockIndex` unmodified but will clear the
associated `Session` of the key. The key must be held by this session to be
unlocked.

+ Parameters
    + flags (optional, num) ... an unsigned value between 0 and 2^64-1
    
        Opaque to the user, but client applications may use it.

    + cas (optional, num) ... performs a Check-And-Set operation
    + acquire (optional, session) ... performs a lock acquisition operation
    + release (optional, session) ... performs a lock release operation


+ Request

        value of key

+ Response 200 (application/json)

        true

### Delete a Key [DELETE]

Delete a single key or all keys sharing a prefix.

If the `recurse` parameter is provided, then all keys with the prefix are
deleted, otherwise only the specified key.

+ Parameters
    + recurse (optional) ... all keys with the prefix are deleted

+ Response 200

# Group Agent control

The Agent endpoints are used to interact with a local Consul agent.  Usually,
services and checks are registered with an agent, which then takes on the burden
of registering with the Catalog and performing anti-entropy to recover from
outages.  There are also various control APIs that can be used instead of the
msgpack RPC protocol.

## Checks [/v1/agent/checks]

### Return the checks the local agent is managing [GET]

This endpoint is used to return the all the checks that are registered with the
local agent.  These checks were either provided through configuration files, or
added dynamically using the HTTP API.  It is important to note that the checks
known by the agent may be different than those reported by the Catalog. This is
usually due to changes being made while there is no leader elected.  The agent
performs active anti-entropy, so in most situations everything will be in sync
within a few seconds.

+ Response 200 (application/json)

    + Body
    
            {
                "service:redis": {
                    "Node": "foobar",
                    "CheckID": "service:redis",
                    "Name": "Service 'redis' check",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "redis",
                    "ServiceName": "redis"
                }
            }

## Services [/v1/agent/services]

### Return the services local agent is managing [GET]

This endpoint is used to return the all the services that are registered with
the local agent.  These services were either provided through configuration
files, or added dynamically using the HTTP API.  It is important to note that
the services known by the agent may be different than those reported by the
Catalog.  This is usually due to changes being made while there is no leader
elected.  The agent performs active anti-entropy, so in most situations
everything will be in sync within a few seconds.

+ Response 200 (application/json)

    + Body

            {
                "redis": {
                    "ID": "redis",
                    "Service": "redis",
                    "Tags": null,
                    "Port": 8000
                }
            }


## Members [/v1/agent/members{?wan}]

### Return the members as seen by the local serf agent [GET]

This endpoint returns the members the agent sees in the cluster gossip pool.
Due to the nature of gossip, this is eventually consistent and the results may
differ by agent.  The strongly consistent view of nodes is instead provided by
`/v1/catalog/nodes` (@todo link).

For agents running in server mode, providing `wan=1` returns the list of WAN
members instead of the LAN members which is default.

+ Parameters
    + wan (optional, num) ... `1` returns list of WAN instead of LAN members

+ Response 200 (application/json)

    + Body

            [
                {
                    "Name": "foobar",
                    "Addr": "10.1.10.12",
                    "Port": 8301,
                    "Tags": {
                        "bootstrap": "1",
                        "dc": "dc1",
                        "port": "8300",
                        "role": "consul"
                    },
                    "Status": 1,
                    "ProtocolMin": 1,
                    "ProtocolMax": 2,
                    "ProtocolCur": 2,
                    "DelegateMin": 1,
                    "DelegateMax": 3,
                    "DelegateCur": 3
                }
            ]

## Self [/v1/agent/self]

### Return the local node configuration [GET]

This endpoint is used to return configuration of the local agent and member information.

+ Response 200 (application/json)

    + Body
    
            {
                "Config": {
                    "Bootstrap": true,
                    "Server": true,
                    "Datacenter": "dc1",
                    "DataDir": "/tmp/consul",
                    "DNSRecursor": "",
                    "Domain": "consul.",
                    "LogLevel": "INFO",
                    "NodeName": "foobar",
                    "ClientAddr": "127.0.0.1",
                    "BindAddr": "0.0.0.0",
                    "AdvertiseAddr": "10.1.10.12",
                    "Ports": {
                        "DNS": 8600,
                        "HTTP": 8500,
                        "RPC": 8400,
                        "SerfLan": 8301,
                        "SerfWan": 8302,
                        "Server": 8300
                    },
                    "LeaveOnTerm": false,
                    "SkipLeaveOnInt": false,
                    "StatsiteAddr": "",
                    "Protocol": 1,
                    "EnableDebug": false,
                    "VerifyIncoming": false,
                    "VerifyOutgoing": false,
                    "CAFile": "",
                    "CertFile": "",
                    "KeyFile": "",
                    "StartJoin": [],
                    "UiDir": "",
                    "PidFile": "",
                    "EnableSyslog": false,
                    "RejoinAfterLeave": false
                },
                "Member": {
                    "Name": "foobar",
                    "Addr": "10.1.10.12",
                    "Port": 8301,
                    "Tags": {
                        "bootstrap": "1",
                        "dc": "dc1",
                        "port": "8300",
                        "role": "consul",
                        "vsn": "1",
                        "vsn_max": "1",
                        "vsn_min": "1"
                    },
                    "Status": 1,
                    "ProtocolMin": 1,
                    "ProtocolMax": 2,
                    "ProtocolCur": 2,
                    "DelegateMin": 2,
                    "DelegateMax": 4,
                    "DelegateCur": 4
                }
            }

## Join [/v1/agent/join/{address}{?wan}]

### Trigger local agent to join a node [GET]

This endpoint is used to instruct the agent to attempt to connect to a given
address. For agents running in server mode, providing `wan=1` causes the agent
to attempt to join using the WAN pool.

+ Parameters
    + address (required, string) ... address of node to join
    + wan (optional, num) ... `1` joins the WAN instead of the LAN pool

+ Response 200

## Force Leave [/v1/agent/force-leave/{node}]

### Force remove node [GET]

This endpoint is used to instructs the agent to force a node into the left
state.  If a node fails unexpectedly, then it will be in a "failed" state.  Once
in this state, Consul will attempt to reconnect, and additionally the services
and checks belonging to that node will not be cleaned up. Forcing a node into
the left state allows its old entries to be removed.

+ Parameters
    + node (required, string) ... the node to remove

+ Response 200

## Register Check [/v1/agent/check/register]

### Register a new local check [PUT]

The register endpoint is used to add a new check to the local agent.  There is
more documentation on checks
[here](http://www.consul.io/docs/agent/checks.html). Checks are either a script
or TTL type. The agent is responsible for managing the status of the check and
keeping the Catalog in sync.

The `Name` field is mandatory, as is either `Script` and `Interval` or `TTL`.
Only one of `Script` and `Interval` or `TTL` should be provided. If an `ID` is
not provided, it is set to `Name`. You cannot have duplicate `ID` entries per
agent, so it may be necessary to provide an `ID`. The `Notes` field is not used
by Consul, and is meant to be human readable.

If a `Script` is provided, the check type is a script, and Consul will evaluate
the script every `Interval` to update the status. If a `TTL` type is used, then
the TTL update APIs must be used to periodically update the state of the check.

+ Request
    
        {
            "ID": "mem",
            "Name": "Memory utilization",
            "Notes": "Ensure we don't oversubscribe memory",
            "Script": "/usr/local/bin/check_mem.py",
            "Interval": "10s",
            "TTL": "15s"
        }

+ Response 200

## Deregister Check [/v1/agent/check/deregister/{checkID}]

### Deregister a local check [GET]

Remove a check from the local agent.  The agent will take care of deregistering
the check with the Catalog.

+ Response 200

## Set Check Status [/v1/agent/check/{state}/{checkID}{?note}]

### Set status of local test [GET]

This endpoint is used with [TTL
type](http://www.consul.io/docs/agent/checks.html) checks. Sets the check status
and resets the TTL clock.

* state `pass` sets `checkID` to status `passing`
* state `warn` sets `checkID` to status `warning`
* state `fail` sets `checkID` to status `critical`

+ Parameters
    + state (required, enum) ... the state of the check
        + Values
            + `pass`
            + `warn`
            + `fail`
    + checkID (required, string) ... the ID of the check
    + note (optional, string) ... check output
    
        Should be human-readable for operators

+ Response 200

## Register Service [/v1/agent/service/register]

### Registers a new local service [PUT]

The register endpoint is used to add a new service to the local agent.  There is
more documentation on services
[here](http://www.consul.io/docs/agent/services.html). Services may also provide
a health check. The agent is responsible for managing the status of the check
and keeping the Catalog in sync.

The `Name` field is mandatory.  If an `ID` is not provided, it is set to `Name`.
You cannot have duplicate `ID` entries per agent, so it may be necessary to
provide an `ID`. `Tags`, `Port` and `Check` are optional. If `Check` is
provided, only one of `Script` and `Interval` or `TTL` should be provided. There
is more information about checks
[here](http://www.consul.io/docs/agent/checks.html).

The created check will be named `service:<ServiceId>`.


+ Request

        {
            "ID": "redis1",
            "Name": "redis",
            "Tags": [ "master", "v1" ],
            "Port": 8000,
            "Check": {
                "Script": "/usr/local/bin/check_redis.py",
                "Interval": "10s",
                "TTL": "15s"
            }
        }

+ Response 200

## Deregister Service [/v1/agent/service/deregister/{serviceID}]

### Deregister a local service [GET]

Removes a service from the local agent. The agent will take care of
deregistering the service with the Catalog. If there is an associated check,
that is also deregistered.

+ Parameters
    + serviceID (required, string) ... ID of service to deregister

+ Response 200

# Group Catalog

The Catalog is the endpoint used to register and deregister nodes, services, and
checks. It also provides a number of query endpoints.

## Register [/v1/catalog/register]

### Registers a new node, service, or check [PUT]

Low level mechanism for directly registering or updating entries in the catalog.
It is usually recommended to use the agent local endpoints, as they are simpler
and perform anti-entropy.

The behavior of the endpoint depends on what keys are provided. 

The endpoint requires `Node` and `Address` to be provided, while `Datacenter`
will be defaulted to match that of the agent. If only those are provided, the
endpoint will register the node with the catalog.

If the `Service` key is provided, then the service will also be registered. If
`ID` is not provided, it will be defaulted to `Service`. It is mandated that the
`ID` be node-unique. Both `Tags` and `Port` can be omitted.

If the `Check` key is provided, then a health check will also be registered. It
is important to remember that this register API is very low level. This
manipulates the health check entry, but does not setup a script or TTL to
actually update the status. For that behavior, an agent local check should be
setup.

The `CheckID` can be omitted, and will default to the `Name`. Like before, the
`CheckID` must be node-unique. `Notes` is an opaque field that is meant to hold
human readable text. If a `ServiceID` is provided that matches the `ID` of a service
on that node, then the check is treated as a service level health check, instead
of a node level health check. Lastly, the `Status` must be one of `unknown`,
`passing`, `warning`, or `critical`. The `unknown` status is used to indicate
that the initial check has not been performed yet.

It is important to note that `Check` does not have to be provided with `Service`
and visa-versa. They can be provided or omitted at will.

+ Request

        {
            "Datacenter": "dc1",
            "Node": "foobar",
            "Address": "192.168.10.10",
            "Service": {
                "ID": "redis1",
                "Service": "redis",
                "Tags": [
                    "master",
                    "v1"
                ],
                "Port": 8000
            },
            "Check": {
                "Node": "foobar",
                "CheckID": "service:redis1",
                "Name": "Redis health check",
                "Notes": "Script based health check",
                "Status": "passing",
                "ServiceID": "redis1"
            }
        }

+ Response 200


## Deregister [/v1/catalog/deregister]

### Deregisters a node, service, or check [PUT]

Low level mechanism for directly removing entries in the catalog. It is usually
recommended to use the agent local endpoints, as they are simpler and perform
anti-entropy.

+ Request node

        {
            "Datacenter": "dc1",
            "Node": "foobar"
        }

+ Response 200

+ Request check

        {
            "Datacenter": "dc1",
            "Node": "foobar",
            "CheckID": "service:redis1"
        }

+ Response 200

+ Request service

        {
            "Datacenter": "dc1",
            "Node": "foobar",
            "ServiceID": "redis1"
        }

+ Response 200

## Datacenters [/v1/catalog/datacenters]

### Lists known datacenters [GET]

Return all the datacenters that are known by the Consul server.

This endpoint does not require a cluster leader, and as such will succeed even
during an availability outage. It can thus be a simple check to see if any
Consul servers are routable.

+ Response 200 (application/json)

    + Body

            ["dc1", "dc2"]

## Nodes [/v1/catalog/nodes{?dc,wait,index,stale,consistent}]

### Lists nodes in a given DC [GET]

Returns the nodes known about in a given datacenter.

Supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body
    
            [
                {
                    "Node": "baz",
                    "Address": "10.1.10.11"
                },
                {
                    "Node": "foobar",
                    "Address": "10.1.10.12"
                }
            ]

## Services [/v1/catalog/services{?dc,wait,index,stale,consistent}]

### Lists services in a given DC [GET]

Returns the services known about in a given datacenter.

The main object keys are the service names, while the array provides all the
known tags for a given service.

Supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body
    
            {
                "consul": [],
                "redis": [],
                "postgresql": [
                    "master",
                    "slave"
                ]
            }

## Nodes for Service [/v1/catalog/service/<service>{?tag,dc,wait,index,stale,consistent}]

### Lists the nodes in a given service [GET]

Returns the nodes providing a service in a given datacenter.  By default all
nodes in that service are returned. However, the list can be filtered by tag
using the `tag` query parameter.

Supports blocking queries and all consistency modes.

+ Parameters
    + tag (optional, string)            ... tag to filter on
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body

            [
                {
                    "Node": "foobar",
                    "Address": "10.1.10.12",
                    "ServiceID": "redis",
                    "ServiceName": "redis",
                    "ServiceTags": null,
                    "ServicePort": 8000
                }
            ]

## Services for Node [/v1/catalog/node/<node>{?dc,wait,index,stale,consistent}]

### Lists the services provided by a node [GET]

Returns the node-provided services.

Supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body

            {
                "Node": {
                    "Node": "foobar",
                    "Address": "10.1.10.12"
                },
                "Services": {
                    "consul": {
                        "ID": "consul",
                        "Service": "consul",
                        "Tags": null,
                        "Port": 8300
                    },
                    "redis": {
                        "ID": "redis",
                        "Service": "redis",
                        "Tags": [
                            "v1"
                        ],
                        "Port": 8000
                    }
                }
            }

# Group Health

The Health endpoints are used to query health related information. It is
provided separately from the Catalog, since users may prefer to not use the
health checking mechanisms as they are totally optional. Additionally, some of
the query results from the Health system are filtered, while the Catalog
endpoints provide the raw entries.

## Node [/v1/health/node/{node}{?dc,index,wait,stale,consistent}]

### Returns the health info of a node [GET]

Returns the node specific checks known.

In the sample response body, we can see there is a system level check (no
associated `ServiceID`, as well as a service check for Redis). The "serfHealth"
check is special, in that all nodes automatically have this check. When a node
joins the Consul cluster, it is part of a distributed failure detection provided
by Serf. If a node fails, it is detected and the status is automatically changed
to "critical".

+ Parameters
    + node (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body

            [
                {
                    "Node": "foobar",
                    "CheckID": "serfHealth",
                    "Name": "Serf Health Status",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "",
                    "ServiceName": ""
                },
                {
                    "Node": "foobar",
                    "CheckID": "service:redis",
                    "Name": "Service 'redis' check",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "redis",
                    "ServiceName": "redis"
                }
            ]

## Checks [/v1/health/checks/{service}{?dc,index,wait,stale,consistent}]

### Returns the checks of a service [GET]

Returns the checks associated with a service.

+ Parameters
    + service (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)

## Service [/v1/health/service/{service}{?dc,index,wait,stale,consistent,tag,passing}]

### Returns the nodes and health info of a service [GET]

Returns the service nodes providing a given service.

By default all nodes in that service are returned.  However, the list can be
filtered by tag using the `tag` query parameter.

This is very similar to the `/v1/catalog/service endpoint`, however this
endpoint automatically returns the status of the associated health check, as
well as any system level health checks. This allows a client to avoid sending
traffic to nodes failing health tests, or who are reporting warnings.

Providing the `passing` query parameter will filter results to only nodes with
all checks in the passing state. This can be used to avoid some filtering logic
on the client side. (Added in Consul 0.2)

Users can also built in support for dynamic load balancing and other features by
incorporating the use of health checks.

+ Parameters
    + service (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode
    + tag (optional, string)            ... tag to filter on
    + passing (optional)                ... if provided, return only passing nodes

+ Response 200 (application/json)
    + Body
    
            [
                {
                    "Node": {
                        "Node": "foobar",
                        "Address": "10.1.10.12"
                    },
                    "Service": {
                        "ID": "redis",
                        "Service": "redis",
                        "Tags": null,
                        "Port": 8000
                    },
                    "Checks": [
                        {
                            "Node": "foobar",
                            "CheckID": "service:redis",
                            "Name": "Service 'redis' check",
                            "Status": "passing",
                            "Notes": "",
                            "Output": "",
                            "ServiceID": "redis",
                            "ServiceName": "redis"
                        },
                        {
                            "Node": "foobar",
                            "CheckID": "serfHealth",
                            "Name": "Serf Health Status",
                            "Status": "passing",
                            "Notes": "",
                            "Output": "",
                            "ServiceID": "",
                            "ServiceName": ""
                        }
                    ]
                }
            ]

## State [/v1/health/state/{state}{?dc,index,wait,stale,consistent}]

### Returns the checks in a given state [GET]

Returns the checks in a specific state.

The state being queried must be provided after the slash. The supported states
are "any", "unknown", "passing", "warning", or "critical". The "any" state is a
wildcard that can be used to return all the checks.

+ Parameters
    + state (required, enum)
        + Values
            + `any`
            + `unknown`
            + `passing`
            + `warning`
            + `critical`
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)

# Group Session

The Session endpoints are used to create, destroy and query sessions.

## Create [/v1/session/create{?dc}]

### Creates a new session [PUT]

Initialize a new session. There is more documentation on sessions
[here](http://www.consul.io/docs/internals/sessions.html).  Sessions must be
associated with a node, and optionally any number of checks. By default, the
agent uses its own node name, and provides the "serfHealth" check, along with a
15 second lock delay.

By default, the agent's local datacenter is used, but another datacenter can be
specified using the `dc` query parameter. It is not recommended to use cross-
region sessions.

None of the fields are mandatory, and in fact no request body is required if the
defaults are to be used. The `LockDelay` field can be specified as a duration
string using a "s" suffix for seconds. It can also be a numeric value. Small
values are treated as seconds, and otherwise it is provided with nanosecond
granularity.

The `Node` field must refer to a node that is already registered. By default,
the agent will use its own name. The `Name` field can be used to provide a human
readable name for the Session. Lastly, the `Checks` field is used to provide a
list of associated health checks. By default the "serfHealth" check is provided.
It is highly recommended that if you override this list, you include that check.

The response contains the ID of the newly-created session.

+ Parameters
    + dc (optional, string) ... datacenter to query; defaults to agent's datacenter

+ Request

        {
            "LockDelay": "15s",
            "Name": "my-service-lock",
            "Node": "foobar",
            "Checks": ["a", "b", "c"]
        }

+ Response 200 (application/json)
    + Body
    
            {
                "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e"
            }

## Destroy [/v1/session/destroy/{session}{?dc}]

### Destroys a given session [PUT]

Destroys the given session.

+ Parameters
    + session (required, string) ... session ID to destroy
    + dc (optional, string)      ... datacenter to query; defaults to agent's datacenter

+ Response 200

## Info [/v1/session/info/{session}{?dc,index,wait,stale,consistent}]

### Queries a given session [GET]

Returns the session information by ID.

If the session is not found, `null` is returned instead of a JSON list.

This endpoint supports blocking queries and all consistency modes.

+ Parameters
    + session (required, string)        ... session ID to query
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body

            [
                {
                    "LockDelay": 1.5E+10,
                    "Checks": [
                        "serfHealth"
                    ],
                    "Node": "foobar",
                    "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e",
                    "CreateIndex": 1086449
                }
            ]

## Sessions for Node [/v1/session/node/{node}{?dc,index,wait,stale,consistent}]

### Lists sessions belonging to a node [GET]

Returns the active sessions for a given node.

This endpoint supports blocking queries and all consistency modes.

+ Parameters
    + node (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body

            [
                {
                    "LockDelay": 1.5E+10,
                    "Checks": [
                        "serfHealth"
                    ],
                    "Node": "foobar",
                    "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e",
                    "CreateIndex": 1086449
                },
                ...
            ]

## List [/v1/session/list{?dc,index,wait,stale,consistent}]

### Lists all the active sessions [GET]

Returns the active sessions for a given datacenter.

This endpoint supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Body

            [
                {
                    "LockDelay": 1.5E+10,
                    "Checks": [
                        "serfHealth"
                    ],
                    "Node": "foobar",
                    "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e",
                    "CreateIndex": 1086449
                },
                ...
            ]
